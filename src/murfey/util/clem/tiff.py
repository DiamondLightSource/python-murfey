"""
Contains functions to process the TIFF files generated by the LM's auto-save feature,
grouping them into image stacks according to the correct channels.
"""

from __future__ import annotations

import logging

# import multiprocessing as mp
from pathlib import Path
from typing import List

import numpy as np

from murfey.util import sanitise

# from xml.etree import ElementTree as ET


# from tifffile import imwrite


# from murfey.util.clem import (
#     change_bit_depth,
#     get_image_elements,
#     get_xml_metadata,
#     rescale_across_channel,
#     rescale_to_bit_depth,
# )

# Create logger object to output messages with
logger = logging.getLogger("murfey.util.clem.tiff")


def create_image_stack(file_list: List[Path]) -> np.ndarray:
    """
    Opens the TIFF files provided as NumPy arrays and stacks them.
    """
    return True


def process_tiff_files(
    search_dir: Path,
    root_folder: str,  # Name of the folder to treat as the root folder
    number_of_processes: int = 1,  # Number of processing threads to run
):
    """
    Main function for coordinating the processing of the TIFF files generated by the
    Leica LM's "auto-save" feature.

    The file structure when using "auto-save" differs slightly from that when saving
    as a single .LIF file:

    ___ session_id
        |__ images
        |   |__ position_1
        |       |__ metadata
        |       |   |__ image1.xlif     <-- Actually an XML file
        |       |__ image1--Z00--C00.tiff
        |       |__ image1--Z00--C01.tiff
        |           ... Images for each channel and slice are saved individually
        |   |__ position_2
        |       ...
        |__ processed
            |__ Mimics "images" folder structure
    """

    new_root_folder = "processed"

    # Use the location of TIFF files and their names to identify unique datasets
    # TIFF file names start with "Position..." by default
    tiff_list = list(search_dir.glob("**/Position*.tif"))
    # Remove the "--Z##--C##.tiff" end of the file path strings
    unique_paths = list({Path(str(f).split("--", 1)[0]) for f in tiff_list})
    unique_paths.sort()  # Sort by path alphabetically

    # Use these paths to generate folders for processed images
    for path in unique_paths:
        path_parts = list(path.parts)
        counter = 0
        for p in range(len(path_parts)):
            part = path_parts[p]
            # Remove leading "/" in Unix systems for subsequent rejoining
            if part == "/":
                path_parts[p] = ""
            # Remove spaces to prevent subsequent Murfey errors
            if " " in part:
                part.replace(" ", "_")
            # Save data under "processed instead"
            if part.lower() == root_folder.lower():
                path_parts[p] = new_root_folder
                counter += 0  # Do for first instance only
            # Remove last level in path if same as previous one (redundant naming)
            if p == len(path_parts) - 1:
                if part == path_parts[p - 1]:
                    path_parts.pop(p)
        processed_dir = Path("/".join(path_parts))

        # Check that "processed" has been inserted into file path
        if new_root_folder in str(processed_dir):
            pass
        else:
            logger.error(f"Subpath {sanitise(root_folder)} was not found in file path")
